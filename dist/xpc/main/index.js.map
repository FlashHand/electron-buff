{"version":3,"sources":["../../../src/xpc/main/xpc-task.helper.ts","../../../src/xpc/main/xpc-id.helper.ts","../../../src/pathHelper/main/pathMain.helper.ts","../../../src/xpc/main/xpc-main.helper.ts","../../../src/xpc/main/xpc-center.helper.ts"],"names":["Semaphore","ipcMain","app","webContents"],"mappings":"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","file":"index.js","sourcesContent":["import { Semaphore } from 'rig-foundation';\nimport { XpcPayload } from '../shared/xpc.type';\n\nexport class XpcTask implements XpcPayload {\n  id: string;\n  handleName: string;\n  params?: any;\n  ret?: any;\n\n  private semaphore: Semaphore;\n\n  constructor(payload: XpcPayload) {\n    this.id = payload.id;\n    this.handleName = payload.handleName;\n    this.params = payload.params;\n    this.ret = payload.ret ?? null;\n    this.semaphore = new Semaphore(1);\n    this.semaphore.take(() => {});\n  }\n\n  /** Block until unblock() is called */\n  block(): Promise<void> {\n    return this.semaphore.takeAsync();\n  }\n\n  /** Release the semaphore, unblocking the waiting block() call */\n  unblock(): void {\n    this.semaphore.leave();\n  }\n\n  /** Convert to a plain XpcPayload (serializable for IPC) */\n  toPayload(): XpcPayload {\n    return {\n      id: this.id,\n      handleName: this.handleName,\n      params: this.params,\n      ret: this.ret,\n    };\n  }\n}\n","/**\n * High-performance process-unique ID generator.\n * Combines a random prefix (per process) with an incrementing counter.\n * Guaranteed unique within a single process lifetime.\n */\nconst prefix = Math.random().toString(36).slice(2, 8);\nlet counter = 0;\n\nexport const generateXpcId = (): string => {\n  return `${prefix}-${(++counter).toString(36)}`;\n};\n","import { app, ipcMain } from 'electron';\nimport type { PathName } from '../shared/pathHelper.type';\n\nconst IPC_GET_APP_PATH = '__buff_path_getAppPath__';\nconst IPC_GET_PATH = '__buff_path_getPath__';\nconst IPC_GET_USER_DATA_PATH = '__buff_path_getUserDataPath__';\n\nclass PathMainHelper {\n  init(): void {\n    this.setupListeners();\n  }\n\n  private setupListeners(): void {\n    ipcMain.handle(IPC_GET_APP_PATH, () => {\n      return app.getAppPath();\n    });\n\n    ipcMain.handle(IPC_GET_PATH, (_event, name: PathName) => {\n      return app.getPath(name);\n    });\n\n    ipcMain.handle(IPC_GET_USER_DATA_PATH, () => {\n      return this.getUserDataPath();\n    });\n  }\n\n  /** Get the app installation path */\n  getAppPath(): string {\n    return app.getAppPath();\n  }\n\n  /** Get a special directory or file path by name */\n  getPath(name: PathName): string {\n    return app.getPath(name);\n  }\n\n  /** Get the user data path (e.g. Application Support on macOS, Roaming on Windows) */\n  getUserDataPath(): string {\n    return app.getPath('userData');\n  }\n\n}\n\nexport const pathMainHelper = new PathMainHelper();\n","import { XpcPayload } from '../shared/xpc.type';\nimport { xpcCenter } from './xpc-center.helper';\n\ntype XpcHandler = (payload: XpcPayload) => Promise<any>;\n\n/**\n * XpcMain: runs in the main process.\n * - handle(): register a handler callable by renderers or other main-process code.\n * - send(): invoke a registered handleName (main-process or renderer), delegating to xpcCenter.\n */\nclass XpcMain {\n  private handlers = new Map<string, XpcHandler>();\n\n  /**\n   * Register a handler in the main process.\n   * When another renderer calls send() with this handleName, xpcCenter will\n   * invoke this handler directly (webContentsId = 0) without forwarding to a renderer.\n   */\n  handle(handleName: string, handler: XpcHandler): void {\n    this.handlers.set(handleName, handler);\n    xpcCenter.registerMainHandler(handleName);\n  }\n\n  /**\n   * Get the registered handler for a given handleName.\n   */\n  getHandler(handleName: string): XpcHandler | undefined {\n    return this.handlers.get(handleName);\n  }\n\n  /**\n   * Send a message to a registered handler by handleName.\n   * Delegates to xpcCenter.exec() which handles both main-process and renderer targets.\n   */\n  async send(handleName: string, params?: any): Promise<any> {\n    return xpcCenter.exec(handleName, params);\n  }\n}\n\nexport const xpcMain = new XpcMain();\n","import { ipcMain, webContents } from 'electron';\nimport { XpcPayload } from '../shared/xpc.type';\nimport { XpcTask } from './xpc-task.helper';\nimport { generateXpcId } from './xpc-id.helper';\nimport { pathMainHelper } from '../../pathHelper/main/pathMain.helper';\nimport { xpcMain } from './xpc-main.helper';\n\nconst XPC_REGISTER = '__xpc_register__';\nconst XPC_EXEC = '__xpc_exec__';\nconst XPC_FINISH = '__xpc_finish__';\n\n/**\n * XpcCenter: runs in the main process.\n * - Listens for __xpc_register__: renderer registers a handleName, center stores {handleName → webContentsId}\n * - Listens for __xpc_exec__ (ipcMain.handle): renderer invokes exec, center forwards to target renderer,\n *   blocks via semaphore until __xpc_finish__ is received, then returns result.\n * - Listens for __xpc_finish__: target renderer finished execution, unblocks the pending task.\n */\nclass XpcCenter {\n  /** handleName → webContentsId */\n  private registry = new Map<string, number>();\n  /** task.id → XpcTask (with semaphore block/unblock) */\n  private pendingTasks = new Map<string, XpcTask>();\n\n  init(): void {\n    pathMainHelper.init();\n    this.setupListeners();\n  }\n\n  /**\n   * Register a main-process handleName in the registry with webContentsId = 0.\n   */\n  registerMainHandler(handleName: string): void {\n    this.registry.set(handleName, 0);\n  }\n\n  /**\n   * Execute a handleName: if main-process handler, call directly;\n   * otherwise forward to target renderer, block until __xpc_finish__.\n   * Used by both ipcMain.handle(XPC_EXEC) and xpcMain.send().\n   */\n  async exec(handleName: string, params?: any): Promise<any> {\n    const targetId = this.registry.get(handleName);\n    if (targetId == null) {\n      return null;\n    }\n\n    const payload: XpcPayload = {\n      id: generateXpcId(),\n      handleName,\n      params,\n    };\n\n    // targetId === 0 means the handler is registered in the main process\n    if (targetId === 0) {\n      const handler = xpcMain.getHandler(handleName);\n      if (!handler) {\n        return null;\n      }\n      try {\n        return await handler(payload);\n      } catch (_e) {\n        return null;\n      }\n    }\n\n    const target = webContents.fromId(targetId);\n    if (!target || target.isDestroyed() || target.isCrashed()) {\n      return null;\n    }\n\n    // Create semaphore-blocked task\n    const task = new XpcTask(payload);\n\n    this.pendingTasks.set(task.id, task);\n\n    // Forward handleName event + payload to target renderer\n    target.send(handleName, payload);\n\n    // Block until __xpc_finish__ unblocks\n    await task.block();\n    this.pendingTasks.delete(task.id);\n\n    return task.toPayload().ret ?? null;\n  }\n\n  private setupListeners(): void {\n    // Renderer registers a handleName\n    ipcMain.on(XPC_REGISTER, (event, payload: { handleName: string }) => {\n      this.registry.set(payload.handleName, event.sender.id);\n    });\n\n    // Renderer invokes exec via IPC\n    ipcMain.handle(XPC_EXEC, async (_event, payload: XpcPayload): Promise<any> => {\n      return this.exec(payload.handleName, payload.params);\n    });\n\n    // Target renderer finished execution, unblock pending task\n    ipcMain.on(XPC_FINISH, (_event, payload: XpcPayload) => {\n      const task = this.pendingTasks.get(payload.id);\n      if (task) {\n        task.ret = payload.ret ?? null;\n        task.unblock();\n      }\n    });\n  }\n}\n\nexport const xpcCenter = new XpcCenter();\n"]}